<?xml version="1.0" ?>
<!DOCTYPE book PUBLIC "-//KDE//DTD DocBook XML V4.2-Based Variant V1.1//EN" "dtd/kdex.dtd" [
  <!-- Define an entity for your application if it is not part of KDE
       CVS -->
  <!ENTITY kmyapplication "<application>simon</application>">
  <!ENTITY kappname "&kmyapplication;"><!-- replace kmyapplication here
                                            do *not* replace kappname-->
  <!ENTITY package "kde-module"><!-- kdebase, kdeadmin, etc.  Leave
                                     this unchanged if your
                                     application is not maintained in KDE CVS -->
  <!ENTITY % addindex "IGNORE">
  <!ENTITY % English "INCLUDE"> <!-- ONLY If you are writing non-English
                                     original documentation, change
                                     the language here -->

  <!-- Do not define any other entities; instead, use the entities
       from entities/general.entities and $LANG/user.entities. -->
]>
<!-- kdoctemplate v0.9 January 10 2003
     Changes to comments to clarify entity usage January 10 2003
     Minor update to "Credits and Licenses" section on August 24, 2000
     Removed "Revision history" section on 22 January 2001
     Changed to Installation/Help menu entities 18 October 2001
     Other minor cleanup and changes 18 October 2001
     FPI change and minor changes November 2002 -->

<!--
This template was designed by: David Rugge davidrugge@mindspring.com
with lots of help from: Eric Bischoff ebisch@cybercable.tm.fr
and Frederik Fouvry fouvry@sfs.nphil.uni-tuebingen.de
of the KDE DocBook team.

You may freely use this template for writing any sort of KDE documentation.
If you have any changes or improvements, please let us know.

Remember:
- in XML, the case of the <tags> and attributes is relevant ;
- also, quote all attributes.

Please don't forget to remove all these comments in your final documentation,
thanks ;-).
-->

<!-- ................................................................ -->

<!-- The language must NOT be changed here. -->
<!-- If you are writing original documentation in a language other -->
<!-- than English, change the language above ONLY, not here -->
<book lang="&language;">

<!-- This header contains all of the meta-information for the document such
as Authors, publish date, the abstract, and Keywords -->

<bookinfo>
<title>The &kmyapplication; Handbook</title>

<authorgroup>
<author>
<!-- This is just put in as an example.  For real documentation, please
     define a general entity in entities/contributor.entities, e.g.
<!ENTITY George.N.Ugnacious "<personname><firstname>George</firstname><othername>N.</othername><surname>Ugnacious</surname></personname>">
<!ENTITY George.N.Ugnacious.mail "<email>gnu@kde.org</email>">
and use `&George.N.Ugnacious; &George.N.Ugnacious.mail;' in the author element.
 -->
<personname>
<firstname>Peter</firstname>
<othername>H.</othername>
<surname>Grasch</surname>
</personname>
<email>grasch@simon-listens.org</email>
</author>
</authorgroup>

<!-- TRANS:ROLES_OF_TRANSLATORS -->

<copyright>
<year>2008</year>
<holder>Peter Grasch</holder>
</copyright>
<!-- Translators: put here the copyright notice of the translation -->
<!-- Put here the FDL notice.  Read the explanation in fdl-notice.docbook
     and in the FDL itself on how to use it. -->
<legalnotice>&FDLNotice;</legalnotice>

<!-- Date and version information of the application
Don't forget to include this last date and this last revision number, we
need them for translation coordination !
Please respect the format of the date (YYYY-MM-DD) and of the version
(V.MM.LL), it could be used by automation scripts.
Do NOT change these in the translation. -->

<date>2008-03-04</date>
<releaseinfo>0.02-rc1</releaseinfo>

<!-- Abstract about this handbook -->

<abstract>
<para>
&kmyapplication; is an open source speech recognition solution.
</para>
</abstract>

<!-- This is a set of Keywords for indexing by search engines.
Please at least include KDE, the KDE package it is in, the name
 of your application, and a few relevant keywords. -->

<keywordset>
<keyword>KDE</keyword>
<keyword>kdeutils</keyword>
<keyword>Kapp</keyword>
<keyword>simon</keyword>
<keyword>recognition</keyword>
<keyword>speech</keyword>
<keyword>voice</keyword>
<keyword>command</keyword>
<keyword>control</keyword>
<keyword>accessibility</keyword>
</keywordset>

</bookinfo>

<!-- The contents of the documentation begin here.  Label
each chapter so with the id attribute. This is necessary for two reasons: it
allows you to easily reference the chapter from other chapters of your
document, and if there is no ID, the name of the generated HTML files will vary
from time to time making it hard to manage for maintainers and for the CVS
system. Any chapter labelled (OPTIONAL) may be left out at the author's
discretion. Other chapters should not be left out in order to maintain a
consistent documentation style across all KDE apps. -->

<chapter id="introduction">
<title>Introduction</title>

<!-- The introduction chapter contains a brief introduction for the
application that explains what it does and where to report
problems. Basically a long version of the abstract.  Don't include a
revision history. (see installation appendix comment) -->

<para>
&kmyapplication; is the main front end for the simon open source speech recognition solution.

It is a simond client and provides a graphical user interface for managing the speech model and the commands. Moreover, simon can execute all sorts of commands based on the input it receives from the server: simond.
</para>

<para>
In contrast to existing commercial offerings, simon provides a unique do-it-yourself approach to speech recognition. Instead of pre-defined, pre-trained speech models, simon does not ship with any model whatsoever. Instead, it provides an easy to use end-user interface to create language and acoustic models from scratch.

The current release can be used to set up command-and-control solutions especially suitable for the disabled. However, because of the amount of training nescessairy, continuous, free dictation is neither supported nor reasonable with current versions of simon.
</para>

<para>
Because of it's architecture, the same version of simon can be used with all languages and dialects. One can even mix languages within one model if nescessairy.
</para>
</chapter>


<chapter id="overview">
<title>Overview</title>

<sect1 id="architecture">
<title>Architecture</title>
<para>
The simon consits of three applications.
<itemizedlist>
  <listitem><para>&kmyapplication;</para><para>This is the main graphical interface.</para><para>It acts as a client to the simond server.</para></listitem>
  <listitem><para>simond</para><para>The recognition server.</para></listitem>
  <listitem><para>ksimond</para><para>A graphical front-end for simond.</para></listitem>
</itemizedlist>
</para>

<para>
simon (the solution as a whole) is a server / client solution. That means that there is one server (simond) for one or more clients (&kmyapplication;; This application). KSimond is just a front-end for simond which means it adds no functionality to the system but rather provides a way to interact with simond.
</para>

<para>
<screenshot>
<screeninfo>Architecture</screeninfo>
  <mediaobject>
    <imageobject>
      <imagedata fileref="architecture.png" format="PNG"/>
    </imageobject>
  </mediaobject>
</screenshot>
</para>

<para>&kmyapplication; is used to create and maintain a representation of your pronunciation and language. This representation is then sent to the server simond which compiles it into a usable speech model.</para>
<para>&kmyapplication; then records sound from the microphone and transmits it to the server which runs the recognition on the received input stream. simond sends the recognition result back to the client (&kmyapplication;).</para>
<para>&kmyapplication; then uses this recognition result to execute commands like opening programs, following links, etc.</para>
</sect1>


<sect1 id="speech_model">
<title>Speech Recognition: Background</title>

<para>
Speech recognition systems take voice input (often from a microphone) and try to translate it into written text. To do that, they rely on statistical representations of human voice. To put it into simple terms: The computer learns how words - or more correctly the sounds that make up those words - sound.
</para>

<para>
A speech model consists of two distinct parts:
<itemizedlist>
  <listitem><para>Language Model</para></listitem>
  <listitem><para>Acoustic Model</para></listitem>
</itemizedlist>
</para>

<sect2 id="language_model">
<title>Language Model</title>

<para>The language model defines the vocabulary and the grammar you want to use.</para>
<para>For more information see the <link linkend="wordlist">vocabulary section</link> and the <link linkend="grammar">grammar section</link>.</para>
</sect2>

<sect2 id="acoustic_model">
<title>Acoustic Model</title>
<para>The acoustic model represents your pronunciation in a machine readable format.</para>

<para>Let's look at the following sample vocabulary:
<table frame='all'><title>Sample Vocabulary</title>
<tgroup cols='3' align='left' colsep='1' rowsep='1'>
<colspec colname='c1'/>
<colspec colname='c2'/>
<colspec colname='c3'/>
<thead>
<row>
  <entry>Word</entry>
  <entry>Terminal</entry>
  <entry>Pronunciation</entry>
</row>
</thead>
<tbody>
<row>
  <entry>Computer</entry>
  <entry>Noun</entry>
  <entry>k ax m p y uw t er</entry>
</row>
<row>
  <entry>Internet</entry>
  <entry>Noun</entry>
  <entry>ih n t er n eh t</entry>
</row>
<row>
  <entry>Mail</entry>
  <entry>Noun</entry>
  <entry>m ey l</entry>
</row>
<row>
  <entry>close</entry>
  <entry>Verb</entry>
  <entry>k l ow s</entry>
</row>
</tbody>
</tgroup>
</table>
</para>

<para>
The pronunciation of each words is composed of individual sounds which are seperated by spaces. For example, the word "close" consists of the following sounds:

<itemizedlist>
  <listitem><para>k</para></listitem>
  <listitem><para>l</para></listitem>
  <listitem><para>ow</para></listitem>
  <listitem><para>s</para></listitem>
</itemizedlist>

The acoustic model uses the fact that spoken words are composed of sounds much like written words are composed of letters. Using this knowledge, we can segment words into sounds (represented by the pronunciation) and assemble them back when recognizing. These building blocks are called "phonemes".
</para>

<para>
Because the acoustic model actually represents how you speak the phonemes of the words, trainings material is shared among all words that use the same phonemes.
</para>
<para>
That means if you add the word "clothes" to the language model, your acoustic model already has an idea how the "clo" part is going to sound as they share the same phonemes ("k", "l", "ow") at the beginning.
</para>
<para>
To train the acoustic model (in other words to tell him how you pronounce the phonemes) you have to "train" words from your language model. That means that simon displays a word which you read out loud. Because the word is listed in your vocabulary, simon already knows what phonemes it contains and can thus "learn" from your pronunciation of your word.
</para>
</sect2>
</sect1>
</chapter>

<chapter id="guidelines">
<title>Guidelines</title>
<para>This chapter lists some general guidelines that are relevant for different parts of simon.</para>

<sect1 id="recording">
<title>Recordings</title>
<para>simon builds it's acoustic model based on transcribed samples of the users voice. Because of this, the recorded samples are of vital importance for the recognition.</para>

<sect2 id="volume">
<title>Volume</title>
<para>It is important that you check your microphone volume before recording any samples.</para>
<para>A simple way to ensure that your microphone is configured correctly is to use an audio editing tool like the free <ulink url="http://audacity.sourceforge.net">Audacity</ulink>.</para>

<para>Open the program and start the recording. Say a few words. Don't yell but don't be so quiet either. Take into account that you should generally use the same volume setting for all your training and for the recognition too. You might speak a little bit louder (unconsiously) when you are upset or at another time of the day so try to raise your voice a little bit to anticipate this. It is much better to have a little quieter samples than to start clipping.</para>


<para>
Too quiet:
<screenshot>
<screeninfo>Volume: Too quiet</screeninfo>
  <mediaobject>
    <imageobject>
      <imagedata fileref="too_quiet.png" format="PNG"/>
    </imageobject>
  </mediaobject>
</screenshot>
</para>

<para>
Too loud:
<screenshot>
<screeninfo>Volume: Too loud</screeninfo>
  <mediaobject>
    <imageobject>
      <imagedata fileref="too_loud.png" format="PNG"/>
    </imageobject>
  </mediaobject>
</screenshot>
</para>

<para>
Perfect volume:
<screenshot>
<screeninfo>Perfect volume</screeninfo>
  <mediaobject>
    <imageobject>
      <imagedata fileref="volume_perfect.png" format="PNG"/>
    </imageobject>
  </mediaobject>
</screenshot>
</para>

</sect2>

<sect2 id="silence">
<title>Silence</title>
<para>To help simon with the automatic segmentation it is recommended to leave about one or two seconds of silence on the recording before and after reading the prompted text.</para>
</sect2>
</sect1>
</chapter>


<chapter id="using-simon">
<title>Using &kmyapplication;</title>

<sect1 id="using_overview">
<title></title>
<para>
The following chapter will provide an overview over the usage of simon.
<screenshot>
<screeninfo>A screenshot of &kmyapplication;</screeninfo>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="screenshot_main.png" format="PNG"/>
	  </imageobject>
	  <textobject>
	    <phrase>Screenshot</phrase>
	  </textobject>
	</mediaobject>
</screenshot>
</para>
</sect1>


<sect1 id="wordlist">
<title>Wordlist</title>
<para>The wordlist lets the user manage the vocabulary.</para>

<sect2 id="wordlist_theory">
<title>General</title>
<para>
The vocabulary defines what words the recognition process should recognize. Every word you want to be able to use with simon should be contained in your vocabulary.
</para>
<para>
One entry in the vocabulary defines exactly one "word". In contrast to common use of the word "word", in simon "word" means one unique combination of the following:
<itemizedlist>
  <listitem><para>Wordname</para><para>(The written word itself)</para></listitem>
  <listitem><para>Terminal</para><para>(Grammatical category; For example: "Noun", "Verb", etc.)</para></listitem>
  <listitem><para>Pronunciation</para><para>(How the word is pronounced; simon accepts any kind of phonetic as long as it does not use special characters or numbers)</para></listitem>
</itemizedlist>

That means that plurals or even different cases are different "words" to simon.
This is an important design decicion to allow more control when using a sophisticated grammar.
</para>

<para>
In general, it is advisable to keep your vocabulary as sleek as possible. The more words, the higher the chance that simon might misunderstand you.
</para>

<para>
Example vocabulary (please note that the terminals here are deliberately set to Noun / Verb to help the understanding; Please to refer to the <link linkend="grammar">grammar section</link> why this might not be the best idea):
<table frame='all'><title>Sample Vocabulary</title>
<tgroup cols='3' align='left' colsep='1' rowsep='1'>
<colspec colname='c1'/>
<colspec colname='c2'/>
<colspec colname='c3'/>
<thead>
<row>
  <entry>Word</entry>
  <entry>Terminal</entry>
  <entry>Pronunciation</entry>
</row>
</thead>
<tbody>
<row>
  <entry>Computer</entry>
  <entry>Noun</entry>
  <entry>k ax m p y uw t er</entry>
</row>
<row>
  <entry>Internet</entry>
  <entry>Noun</entry>
  <entry>ih n t er n eh t</entry>
</row>
<row>
  <entry>Mail</entry>
  <entry>Noun</entry>
  <entry>m ey l</entry>
</row>
<row>
  <entry>close</entry>
  <entry>Verb</entry>
  <entry>k l ow s</entry>
</row>
</tbody>
</tgroup>
</table>
</para>

<sect3 id="active_dictionary">
<title>Active Dictionary</title>
<para>The vocabulary used for the recognition is referred to as active dictionary or active vocabulary.</para>
</sect3>

<sect3 id="shadow_dictionary">
<title>Shadow Dictionary</title>
<para>
As said above, the user should keep his vocabulary / dictionary as lean as possible. However, as a word in your vocabulary has to also have information about it's pronunciation, it would also be good to have large dictionary where you could look up the pronunciation and other characteristics of the words.
</para>
<para>
simon provides this functionality. We refer to this large reference dictionary as "shadow dictionary". This shadow dictionary is not created by the user but can be imported from various sources.
</para>
<para>
As simon is a multi-language solution we do not ship shadow dictionaries with simon. However, it is very easy to import them yourself using the import dictionary wizard. This is described in the <link linkend="import_dictionary">Import Dictionary section</link>.
</para>
</sect3>
</sect2>



<sect2>
<title>Maintaining the Wordlist</title>
<para>
simon provides a "Wordlist" menu which lists the current vocabulary.

<screenshot>
<screeninfo>simons Wordlist</screeninfo>
  <mediaobject>
    <imageobject>
      <imagedata fileref="wordlist.png" format="PNG"/>
    </imageobject>
  </mediaobject>
</screenshot>
</para>

<para>Per default, only the active vocabulary is shown. Only after you tick the "Include unused Words from the Shadow Lexicon" checkbox the shadow lexicon is also shown.</para>

<para>
Every word states it "recognition rate" which at the moment is just a counter of how often the word has been recorded (alone or together with other words).
</para>
<para>
When this number is only one or zero the word entry is colored red (1: light red; 0: dark red). This is a visual warning. When a word contains a phoneme combination that is not covered by any other word and the word with this unusual phoneme combination is never recorded (recognition rate = 0), the model <emphasis>will</emphasis> fail to compile. However, simon will display an appropriate error message when the compilation of the model fails because of such an issue. In general it is a good idea to record each word at least once or twice (at best when <link linkend="add_word_record">adding the word</link>) to avoid such problems.
</para>
<para>Because the shadow dictionary is not used for the recognition there are of course no trainings samples for words in the shadow dictionary. So don't be alarmed if all the entries in the shadow dictionary are colored dark red - this is perfectly normal.

<screenshot>
<screeninfo>Shadow Wordlist</screeninfo>
  <mediaobject>
    <imageobject>
      <imagedata fileref="wordlist1.png" format="PNG"/>
    </imageobject>
  </mediaobject>
</screenshot>


</para>

</sect2>


<sect2 id="add_word">
<title>Adding Words</title>
<para>To add new words to the active vocabulary, use the add word wizard.</para>
<para>Adding words to simon is basically a two step procedure:
<itemizedlist>
<listitem><para>Defining the word</para></listitem>
<listitem><para>Initial training</para></listitem>
</itemizedlist>
</para>

<sect3 id="add_word_define">
<title>Defining the Word</title>
<para>
Firstly, the user is asked which word he wants to add.

<screenshot>
<screeninfo>Select the word to add</screeninfo>
  <mediaobject>
    <imageobject>
      <imagedata fileref="add_word_1.png" format="PNG"/>
    </imageobject>
  </mediaobject>
</screenshot>
</para>

<para>
When the user proceeds to the next page, simon automatically tries to find as much information about the word in the <link linkend="shadow_dictionary">shadow dictionary</link> as possible.
</para>

<para>
If the word is listed in the shadow dictionary, simon automatically fills out all the needed fields (Terminal and Pronunciation).

<screenshot>
<screeninfo>Fields automatically filled out by the Shadow Dictionary</screeninfo>
  <mediaobject>
    <imageobject>
      <imagedata fileref="add_word_2.png" format="PNG"/>
    </imageobject>
  </mediaobject>
</screenshot>
</para>
<para> All suggestions from the shadow dictionary are listed in the table "Similar words". Per default only exact word matches are shown. However, this can be changed by checking the "Also show non-perfect matches" checkbox below the suggestion table. Using similar words you can quickly deduce the correct pronunciation of the word you are actually trying to add. See <link linkend="manual_transcription">below</link> for details.</para>

<para>
Of course this really depends on your shadow dictionary. If the shadow dictionary does not contain the word you are trying to add, the required fields have to be filled out manually.</para>

<para>
Some dictionaries that can be imported with simon (SPHINX, HTK) to not differentiate between upper and lower case. Suggestions based on those dictionaries will always be uppercase. You are of course free to change these suggestions to the correct case.
</para>

<para>Some dictionaries that can be imported with simon (SPHINX, PLS and HTK) provide no grammatical information at all. These will assign all the words to the terminal "Unknown". You should change this to something appropriate when adding those words.
</para>

<sect4>
<title>Manually Selecting a Terminal</title>
<para>
The terminal of the word is defined as the grammatical category the word belongs to. This might be "Noun", "Verb" or completely new categories like "Command". For more information see the <link linkend="grammar">grammar section</link>.</para>
<para>
The list contains all terminals used in both your active and your shadow lexicon and in your grammar.
</para>
<para>
You can add new terminals to the drop-down menu by using the green plus sign next to it.
</para>
</sect4>

<sect4 id="manual_transcription">
<title>Manually Providing the Phonetic Transcription</title>
<para>
The pronunciation is a bit trickier. simon does not need a certain type of phonetics so you are free to use any method as long as it uses only ASCII characters and no numbers. However, if you want to use a shadow dictionary and want to use it to it's full potential you should use the same phonetics as the shadow dictionary.
</para>

<para>
If you don't know how to transcribe a word yourself you can easily use your shadow dictionary to help you with the transcription - even if the word is not listed in it. Let's say we want to add the word "Firefox" (to launch firefox) which is of course not listed in our shadow dictionary.
</para>

<para>
(I imported the English voxforge HTK lexicon available from <ulink url="http://voxforge.org/home/downloads">voxforge</ulink> as a shadow dictionary.)
</para>

<para>
"Firefox" is not listed in our shadow dictionary so we don't get any suggestion at all.
<screenshot>
<screeninfo>Adding an unknown word</screeninfo>
  <mediaobject>
    <imageobject>
      <imagedata fileref="add_word_2_2.png" format="PNG"/>
    </imageobject>
  </mediaobject>
</screenshot>
</para>

<para>
However, we know that firefox sounds like "fire" and "fox" put together. So let's just open the wordlist (you can keep the wizard open) by selecting "Wordlist" from your simon main toolbar.
</para>
<para>
Check the "Include unused words from the shadow lexicon" checkbox beneath the list and simon will display both active and shadow dictionary.
</para>
<para>
Use the "Filter"-Box above the list to search for "Fire":

<screenshot>
<screeninfo>Adding an unknown word: Search for the Pronunciation</screeninfo>
  <mediaobject>
    <imageobject>
      <imagedata fileref="add_word_2_3.png" format="PNG"/>
    </imageobject>
  </mediaobject>
</screenshot>
</para>

<para>
We can see, that the word "Fire" is transcribed as "f ay r". Now filter for "fox" instead of "Fire" and we can see that "Fox" is transcribed as "f ao k s". We can assume, that firefox should be transcribed as "f ay r f ao k s".
</para>

<para>
Using this approach of deducing the pronunciation from parts of the word has the distinct advantage that we not only get a high quality transcription but also automatically use the same phoneme set as the other words which were correctly pulled out of the shadow dictionary.
</para>

<para>
We can now enter the pronunciation and change the terminal to something appropriate.
<screenshot>
<screeninfo>Completely defined word</screeninfo>
  <mediaobject>
    <imageobject>
      <imagedata fileref="add_word_2_4.png" format="PNG"/>
    </imageobject>
  </mediaobject>
</screenshot>
</para>

</sect4>

</sect3>

<sect3 id="add_word_record">
<title>Training the Word</title>
<para>
To complete the wizard we need to train the word twice. (Note: If you are really sure what you are doing you can skip this)
</para>
<para>
simon will try to prompt you for real-world examples. To do that, simon will automatically fetch grammar structures using the terminal of the word and substitute the generic terminals with example words from your active lexicon.
</para>
<para>
For example: You have the grammar structure "Trigger Command" and have the word "Computer" of the terminal "Trigger" in your wordlist. You then add a new word "Firefox" of the terminal "Command". simon will now automatically prompt you for "Computer Firefox" as it is - according to your grammar - a valid sentence.
</para>
<para>
If simon is unable to find appropriate sentences using the word (i.e.: No grammar, not enough words in your active lexicon, etc.) it will just prompt you for the word alone.
</para>
<para>
Altough simon ensures that the automatically generated examples are valid, you can always override it's suggestion. Just switch to the "Examples" tab on the "Define Word" page.
<screenshot>
<screeninfo>Editing word examples</screeninfo>
  <mediaobject>
    <imageobject>
      <imagedata fileref="add_word_3.png" format="PNG"/>
    </imageobject>
  </mediaobject>
</screenshot>
</para>

<para>
You are free to change those examples to anything you like. You can even go so far and use words that are not yet in your active lexicon as long as you add them before you synchronize the model, altough this is not recommended.
</para>

<para>
All that is left is to record the examples.
<screenshot>
<screeninfo>Recording</screeninfo>
  <mediaobject>
    <imageobject>
      <imagedata fileref="add_word_4.png" format="PNG"/>
    </imageobject>
  </mediaobject>
</screenshot>
</para>
<para>Make sure you follow the guidelines listed in the <link linkend="recording">recording section</link>.</para>
</sect3>

</sect2>


<sect2 id="remove_word">
<title>Removing a word</title>

<para>To remove a word from your language model, select it in the wordlist view and click on "Remove selected word".

<screenshot>
<screeninfo>Recording</screeninfo>
  <mediaobject>
    <imageobject>
      <imagedata fileref="delete_word.png" format="PNG"/>
    </imageobject>
  </mediaobject>
</screenshot></para>

<para>
As you can see, the dialog offers two choices:
<itemizedlist>
  <listitem>
    <para>Move the word to the shadow lexicon</para>
    <para>This will remove the selected word from the active lexicon (and thus from the recognition) but will keep a copy in the shadow vocabulary. All the recordings containing the word will still be lost.</para>
  </listitem>
  <listitem><para>Remove the word completely</para>
    <para>Just remove the word. All the recordings containing the word will of course be removed too.</para></listitem>
</itemizedlist>
</para>

</sect2>



<sect2 id="import_dictionary">
<title>Importing a Dictionary</title>
<para>
simon provides the functionality to import large dictionaries as a reference. This reference dictionary is called <link linkend="shadow_dictionary">shadow dictionary</link>.
</para>
<para>
When the user <link linkend="add_word">adds a new word</link> to the model, he has to define the following characteristics to define this word:
<itemizedlist>
  <listitem><para>Wordname</para></listitem>
  <listitem><para>Terminal</para></listitem>
  <listitem><para>Phonetic definition</para></listitem>
</itemizedlist>
</para>
<para>
These characteristics are taken out of the shadow dictionary if it contains the word in question. A large, high quality shadow dictionary can thus help the user to easily add new words to the model without keeping track of the phoneme set or - in many cases - even let him forget a the phonetic transcription is needed at all.
</para>

<para>
simon is able to import four different types of dictionaries:
<itemizedlist>
  <listitem><para>HADIFIX</para></listitem>
  <listitem><para>HTK</para></listitem>
  <listitem><para>PLS</para></listitem>
  <listitem><para>SPHINX</para></listitem>
</itemizedlist>
</para>


<sect3 id="import_dict_hadifix">
<title>HADIFIX Dictionary</title>
<para>
simon can import HADIFIX dictionaries.
</para>
<para>
One example of a HADIFIX dictionary is the German <ulink url="http://www.ifk.uni-bonn.de/forschung/abteilung-sprache-und-kommunikation/phonetik/sprachsynthese/bomp/bomp-1">HADIFIX BOMP</ulink>.
</para>
<para>
Hadifix dictionaries provide both terminals and pronunciation.
</para>
</sect3>

<sect3 id="import_dict_htk">
<title>HTK Dictionary</title>
<para>
simon can import HTK lexica.
</para>
<para>
One example of a HTK lexicon is the English <ulink url="http://www.repository.voxforge1.org/downloads/SpeechCorpus/Trunk/Lexicon/">Voxforge dictionary</ulink>.
</para>
<para>
Hadifix dictionaries provide pronunciation information but no terminals. All words will be assigned to the terminal "Unknown".
</para>
</sect3>

<sect3 id="import_dict_pls">
<title>PLS Dictionary</title>
<para>
simon can import PLS dictionaries.
</para>
<para>
One example of a PLS dictionary is the <ulink url="http://www.repository.voxforge1.org/downloads/de/Trunk/Lexicon/">German GPL dictionary from Voxforge</ulink>.
</para>
<para>
PLS dictionaries provide pronunciation information but no terminals. All words will be assigned to the terminal "Unknown".
</para>
</sect3>

<sect3 id="import_dict_sphinx">
<title>SPHINX Dictionary</title>
<para>
simon can import SPHINX dictionaries.
</para>
<para>
One example of a SPHINX dictionary is this <ulink url="http://speech.mty.itesm.mx/~jnolazco/proyectos.htm">dictionary for Mexican Spanish</ulink>.
</para>
<para>
SPHINX dictionaries provide pronunciation information but no terminals. All words will be assigned to the terminal "Unknown".
</para>
</sect3>

</sect2> <!-- End Import Dict -->

</sect1> <!-- End Wordlist -->


<sect1 id="grammar">
<title>Grammar</title>
<para>
The grammar defines which combinations of words are correct.
</para>

<sect2 id="grammar_general">
<title>General</title>
<para>
Let's look at an example: You want to use simon to launch programs and close those windows when you are done. You would like to use the following commands:
<itemizedlist>
  <listitem><para>"Computer, Internet" to open a browser</para></listitem>
  <listitem><para>"Computer, Mail"</para><para>To open a mail client</para></listitem>
  <listitem><para>"Computer, close"</para><para>To close the current window</para></listitem>
</itemizedlist>
</para>
<para>
Following english grammar, your vocabulary would contain the following:

<table frame='all'><title>Sample Vocabulary</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<colspec colname='c1'/>
<colspec colname='c2'/>
<thead>
<row>
  <entry>Word</entry>
  <entry>Terminal</entry>
</row>
</thead>
<tbody>
<row>
  <entry>Computer</entry>
  <entry>Noun</entry>
</row>
<row>
  <entry>Internet</entry>
  <entry>Noun</entry>
</row>
<row>
  <entry>Mail</entry>
  <entry>Noun</entry>
</row>
<row>
  <entry>close</entry>
  <entry>Verb</entry>
</row>
</tbody>
</tgroup>
</table>
</para>

<para>
To allow the sentences defined above simon would need the following grammar:
<itemizedlist>
  <listitem><para>"Noun Noun" for sentences like "Computer Internet"</para></listitem>
  <listitem><para>"Noun Verb" for sentences like "Computer close"</para></listitem>
</itemizedlist>
</para>
<para>
While this would work, it would also allow the combinations "Computer Computer", "Internet Computer", "Internet Internet", etc. which are obviously bogus.
To improve the recognition accuracy, we can try to create a grammar that better reflects what we are trying to do with simon.
</para>

<para>
It is important to remember that you define your own "language" when using simon. That means that you are not bound to grammar rules that exist in whatever language you want to use simon with. For a simple command and control use-case it would for example be advisable to invent new grammatical rules to eliminate the differences between different commands imposed by grammatical information not relevant for this use case.
</para>

<para>
In the example above it is for example not relevant that "close" is a verb or that "Computer" and "Internet" are nouns. Instead, why not define them as something that better reflects what we want them to be:

<table frame='all'><title>Improved Sample Vocabulary</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<colspec colname='c1'/>
<colspec colname='c2'/>
<thead>
<row>
  <entry>Word</entry>
  <entry>Terminal</entry>
</row>
</thead>
<tbody>
<row>
  <entry>Computer</entry>
  <entry>Trigger</entry>
</row>
<row>
  <entry>Internet</entry>
  <entry>Command</entry>
</row>
<row>
  <entry>Mail</entry>
  <entry>Command</entry>
</row>
<row>
  <entry>close</entry>
  <entry>Command</entry>
</row>
</tbody>
</tgroup>
</table>
</para>

<para>
Now we change the grammar to the following:
<itemizedlist>
  <listitem><para>"Trigger Command"</para></listitem>
</itemizedlist>

This allows all the combinations described above. However, it also limits the possibilities to exactly those three sentences. Especially in larger models a well thought grammar and vocabulary can mean a huge difference in recognition results.
</para>
</sect2>

<sect2>
<title>Defining your Grammar</title>
<para> 
simon provides an easy to use text based interface to change the grammar. You can simply list all the allowed sentences (without any punctuation marks, obviously) like described above.

<screenshot>
<screeninfo>Grammar</screeninfo>
  <mediaobject>
    <imageobject>
      <imagedata fileref="grammar.png" format="PNG"/>
    </imageobject>
  </mediaobject>
</screenshot>
</para>
</sect2>

<sect2>
<title>Import a Grammar</title>
<para>Additionally to simply entering your desired grammar sentence by sentence, simon is able to automatically deduce allowed grammar structures by reading plaintext using the Import Grammar wizard.


<screenshot>
<screeninfo>Import Grammar</screeninfo>
  <mediaobject>
    <imageobject>
      <imagedata fileref="import_grammar.png" format="PNG"/>
    </imageobject>
  </mediaobject>
</screenshot>
</para>

<para>Say we have a vocabulary like in the general section above: 

<table frame='all'><title>Improved Sample Vocabulary</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<colspec colname='c1'/>
<colspec colname='c2'/>
<thead>
<row>
  <entry>Word</entry>
  <entry>Terminal</entry>
</row>
</thead>
<tbody>
<row>
  <entry>Computer</entry>
  <entry>Trigger</entry>
</row>
<row>
  <entry>Internet</entry>
  <entry>Command</entry>
</row>
<row>
  <entry>Mail</entry>
  <entry>Command</entry>
</row>
<row>
  <entry>close</entry>
  <entry>Command</entry>
</row>
</tbody>
</tgroup>
</table></para>

<para>We want simon to recognize the sentence "Computer Internet!". So we create a simple text file with this content "Computer Internet!" (any punctuation mark would work) and save it as "simongrammar.txt".

<screenshot>
<screeninfo>Import Grammar: Text</screeninfo>
  <mediaobject>
    <imageobject>
      <imagedata fileref="import_grammar2.png" format="PNG"/>
    </imageobject>
  </mediaobject>
</screenshot>

<screenshot>
<screeninfo>Import Grammar: Select files</screeninfo>
  <mediaobject>
    <imageobject>
      <imagedata fileref="import_grammar1.png" format="PNG"/>
    </imageobject>
  </mediaobject>
</screenshot>
</para>

<para>simon will then read all the given text files (in this case the only given text file is "simongrammar.txt") and look up every single word in both active and shadow dictionary (the definition in the active dictionary has more importance if the word is available in both). It will then replace the word with its terminal.</para>
<para>In our example this would mean that he would find the sentence "Computer Internet". simon would find out that "Computer" is of the terminal "Trigger" and "Internet" of the terminal "Command". Because of this simon would "learn" that "Trigger Command" is a valid sentence and add it to its grammar.</para>
<para>The import automatically segments the input text files by punctuation marks (".", " - ", "!", etc.) so any natural text should work. The importer will automatically merge duplicate sentence structures (even accross different files) and add multiple sentence (all possible combinations) when a word has multiple terminals assigned to it.</para>
<para>The import will ignore sentences where one or more words could not be found in the language model unless you tick the "Also import unknown sentences" checkbox in which case those words are replaced with "Unknown".</para> 

</sect2>





<sect2>
<title>Renaming Terminals</title>
<para>The rename terminal wizard allows you to rename terminals in both your active vocabulary, your shadow dictionary and the grammar.

<screenshot>
<screeninfo>Rename Terminal</screeninfo>
  <mediaobject>
    <imageobject>
      <imagedata fileref="rename_terminal.png" format="PNG"/>
    </imageobject>
  </mediaobject>
</screenshot>
</para>
</sect2>

<sect2>
<title>Merging Terminals</title>
<para>The merge terminal wizard allows you to merge two terminals into one new terminal in both your active vocabulary, your shadow dictionary and the grammar.

<screenshot>
<screeninfo>Merge Terminal</screeninfo>
  <mediaobject>
    <imageobject>
      <imagedata fileref="merge_terminal.png" format="PNG"/>
    </imageobject>
  </mediaobject>
</screenshot>
</para>
<para>This functionality is especially useful if you want to simplify your grammar structures.</para>
</sect2>


</sect1>



<sect1 id="training">
<title>Training</title>

<para>Info about the training

<screenshot>
<screeninfo>Training</screeninfo>
  <mediaobject>
    <imageobject>
      <imagedata fileref="training.png" format="PNG"/>
    </imageobject>
  </mediaobject>
</screenshot>
</para>

<sect2 id="import_texts">
<title>Importing Texts</title>
<para> </para>
</sect2>

<sect2 id="import_trainingsdata">
<title>Importing Trainingsdata</title>
<para> </para>
</sect2>

</sect1>


<sect1 id="commands">
<title>Commands</title>
<para>Info about the commands</para>

<sect2 id="executable_commands">
<title>Executable Commands</title>
<para> </para>
</sect2>

<sect2 id="place_commands">
<title>Place Commands</title>
<para> </para>
</sect2>

<sect2 id="shortcut_commands">
<title>Shortcut Commands</title>
<para> </para>
</sect2>

<sect2 id="text_macro_commands">
<title>Text-Macro Commands</title>
<para> </para>
</sect2>

<sect2 id="list_command">
<title>List Commands</title>
<para> </para>
</sect2>

<sect2 id="composite_commands">
<title>Composite Commands</title>
<para> </para>
</sect2>

<sect2 id="desktopgrid">
<title>Desktop Grid</title>
<para> </para>
</sect2>

<sect2 id="input_number">
<title>Input Number</title>
<para> </para>
</sect2>

<sect2 id="dictation_command_plugin">
<title>Dictation</title>
<para> </para>
</sect2>
</sect1>


<sect1 id="simond">
<title>simond</title>
<para> </para>

<sect2 id="multiple_simond">
<title>Using simon with multiple simonds</title>
<para> </para>
</sect2>

<sect2 id="model_backup">
<title>Using the automatic model backup</title>
<para> </para>
</sect2>

</sect1>


<sect1 id="recordings">
<title>Configuring Recordings</title>
<para> </para>
</sect1>

<sect1 id="jconfs">
<title>Adjusting the recognition parameters manually</title>

<para>
simon is targeted towards end-users. It's interface is designed to allow even users without any background in speech technology to design their own language and acoustic models by providing reasonable default values for simple uses.
</para>
<para>
In special cases (severe speech impairments for example), special configuration might be needed. This is why the raw configuration files for the recognition are also respected by simon and can of course be modified to suit your needs.
</para>

</sect1>


</chapter>



<chapter id="faq">
<title>Questions and Answers</title>

<!-- (OPTIONAL but recommended) This chapter should include all of the silly
(and not-so-silly) newbie questions that fill up your mailbox. This chapter
should be reserved for BRIEF questions and answers! If one question uses more
than a page or so then it should probably be part of the
"Using this Application" chapter instead. You should use links to
cross-reference questions to the parts of your documentation that answer them.
This is also a great place to provide pointers to other FAQ's if your users
must do some complicated configuration on other programs in order for your
application work. -->

&reporting.bugs;
&updating.documentation;

<qandaset id="faqlist">
<qandaentry>
<question>
<para>My Mouse doesn't work. How do I quit &kmyapplication;?</para>
</question>
<answer>
<para>You silly goose! Check out the <link linkend="using-simon">Using &kmyapplication;</link> for the answer.</para>
</answer>
</qandaentry>
<qandaentry>
<question>
<para>Why can't I twiddle my documents?</para>
</question>
<answer>
<para>You can only twiddle your documents if you have the foobar.lib
installed.</para>
</answer>
</qandaentry>
</qandaset>
</chapter>

<chapter id="credits">

<!-- Include credits for the programmers, documentation writers, and
contributors here. The license for your software should then be included below
the credits with a reference to the appropriate license file included in the KDE
distribution. -->

<title>Credits and License</title>

<para>
&kmyapplication;
</para>
<para>
Program copyright 2006-2009 Peter Grasch <email>grasch@simon-listens.org</email>, Phillip Goriup, Tschernegg Susanne, Bettina Sturmann, Martin Gigerl
</para>
<para>
Contributors:
<itemizedlist>
<listitem><para>Konqui the KDE Dragon <email>konqui@kde.org</email></para>
</listitem>
<listitem><para>Tux the Linux Penguin <email>tux@linux.org</email></para>
</listitem>
</itemizedlist>
</para>

<para>
Documentation Copyright &copy; 2008 George N. Ugnacious <email>gnu@kde.org</email>
</para>

<!-- TRANS:CREDIT_FOR_TRANSLATORS -->

&underFDL;               <!-- FDL: do not remove -->

<!-- Determine which license your application is licensed under,
     and delete all the remaining licenses below:

     (NOTE:  All documentation are licensed under the FDL,
     regardless of what license the application uses) -->

&underGPL;        	 <!-- GPL License -->
&underBSDLicense;        <!-- BSD License -->
&underArtisticLicense;   <!-- BSD Artistic License -->
&underX11License;        <!-- X11 License  -->

</chapter>

<appendix id="installation">
<title>Installation</title>

<sect1 id="getting-kapp">
<title>How to obtain &kmyapplication;</title>

<!-- This first entity contains boiler plate for applications that are
part of KDE CVS.  You should remove it if you are releasing your
application -->

&install.intro.documentation;

</sect1>

<sect1 id="requirements">
<title>Requirements</title>

<!--
List any special requirements for your application here. This should include:
.Libraries or other software that is not included in kdesupport,
kdelibs, or kdebase.
.Hardware requirements like amount of RAM, disk space, graphics card
capabilities, screen resolution, special expansion cards, etc.
.Operating systems the app will run on. If your app is designed only for a
specific OS, (you wrote a graphical LILO configurator for example) put this
information here.
-->

<para>
In order to successfully use &kmyapplication;, you need &kde; 1.1. Foobar.lib is
required in order to support the advanced &kmyapplication; features. &kmyapplication; uses
about 5 megs of memory to run, but this may vary depending on your
platform and configuration.
</para>

<para>
All required libraries as well as &kmyapplication; itself can be found
on <ulink url="ftp://ftp.kapp.org">The &kmyapplication; home page</ulink>.
</para>

<!-- For a list of updates, you may refer to the application web site
or the ChangeLog file, or ... -->
<para>
You can find a list of changes at <ulink
url="http://apps.kde.org/kapp">http://apps.kde.org/kapp</ulink>.
</para>
</sect1>

<sect1 id="compilation">
<title>Compilation and Installation</title>

<!-- This entity contains the boilerplate text for standard -->
<!-- compilation instructions.  If your application requires any -->
<!-- special handling, remove it, and replace with your own text. -->

&install.compile.documentation;

</sect1>

<sect1 id="configuration">
<title>Configuration</title>

<para>Don't forget to tell your system to start the <filename>dtd</filename>
dicer-toaster daemon first, or &kmyapplication; won't work !</para>

</sect1>

</appendix>

&documentation.index;
</book>

<!--
Local Variables:
mode: xml
sgml-minimize-attributes:nil
sgml-general-insert-case:lower
sgml-indent-step:0
sgml-indent-data:nil
End:

vim:tabstop=2:shiftwidth=2:expandtab
kate: space-indent on; indent-width 2; tab-width 2; indent-mode none;
-->
